# @package _global_

# path to original working directory
# hydra hijacks working directory by changing it to the current log directory,
# so it's useful to have this path as a special variable
# learn more here: https://hydra.cc/docs/next/tutorials/basic/running_your_app/working_directory
work_dir: ${hydra:runtime.cwd}

io:
  input_filename: null
  input_dir: null
  output_dir: null
  spatial_reference: 2154  # Peut être donné au format 2154 ou EPSG:2154
  no_data_value: -9999
  extension: .tif  # Extension du fichier de sortie
  raster_driver: "GTiff"
  tile_geometry:
    tile_coord_scale: 1000  # en mètres, échelle à laquelle sont données les coordonnées
    # dans le nom de fichier las (utilisé pour trouver les dalles voisines)
    tile_width: 1000  # en mètres, taille d'une dalle (en général les dalles sont kilométriques)

buffer:
  size: 100  # en mètres, taille du buffer à ajouter pour le calcul à partir des dalles voisines
  output_subdir: null  # Chemin vers le dossier de sortie des dalles avec un buffer (utilisé pour du debug)
                       # (exemple: "tmp/buffer"). utiliser le mot clef null pour ne pas enregistrer ces
                       # fichiers

density:
  pixel_size: 1  # en mètres, taille de pixel pour la carte de densité
  keep_classes:  # Liste des classes pour lesquelles la densité est calculée pour chaque bande.
    - [2]  # band 1 (red)
    - [3, 4, 5, 6, 17]  # band 2 (green)
  colorize: False  # Booléen: si true, la carte de densité est colorisée avec la colormap décrite dans
                   # `density.colormap`. Dans ce cas, keep_classes ne doit contenir qu'une seule bande
  output_subdir: density  # sous-dossier dans lequel est enregistrée la carte de densité

class_map:
  output_class_subdir: "class"  # sous-dossier dans lequel est enregistrée la carte de densité
                                # monobande avec comme valeurs les identifiants de classes, et
                                # avec une carte de classes en métadonnées pour l'affichage dans
                                # les SIG
                                # utiliser null pour ne pas enregistrer cette sortie
  output_class_pretty_subdir: "class_pretty"  # sous-dossier dans lequel est enregistrée la carte de densité
                                              # colorisée (3 bandes RGB) et ombragée
  pixel_size: 0.5  # en mètres, taile de pixel pour la carte de classes
  CBI_rules:  # liste de règles de combinaisons de classes
              # "CBI" contient les classes à aggréger, "AGGREG" la valeur de la classe résultante.
              # par exemple pour {"CBI":[5,6,17], "AGGREG": 50}, si les classes 5, 6 et 17 sont présentes
              # dans le même pixel, ce pixel prendra la valeur 50
    - {"CBI":[5,6,17], "AGGREG": 50}
    - {"CBI":[5,6], "AGGREG": 51}
    - {"CBI":[5,17], "AGGREG": 52}
    - {"CBI":[5,64], "AGGREG": 53}
    - {"CBI":[6,17], "AGGREG": 60}
    - {"CBI":[6,64], "AGGREG": 61}
    - {"CBI":[66,2], "AGGREG": 160}
    - {"CBI":[66,5], "AGGREG": 161}
    - {"CBI":[66,17], "AGGREG": 162}
  precedence_classes:  [61,53,64,50,51,52,161,5,60,162,17,6,67,4,3,160,2,66,9]
    # liste de préséance des classes: si après application des règles de combinaison, plusieurs classes
    # sont encore présentes dans le même pixel, c'est la classe qui apparait le plus tôt dans cette
    # liste qui est conservée
  ignored_classes: [1, 65] # liste des classes à ignorer. Ces classes ne sont pas représentées dans la
                           # carte de classes.
                           # Pour éviter des oublis, si une classe est présente dans les calculs mais
                           # n'est ni dans `precedence_classes`, ni dans `ignored_classes`, une erreur
                           # est levée
  intermediate_dirs:  # dossier de résultats intermédiaires (utilisé pour du debug)
                      # choisir null pour chaque résultat intermédiaire qu'on ne veut pas enregistrer
    class_binary: null  # sous-dossier dans lequel enregistrer les cartes de classes binaires (une bande par classe)
                        # exemple: tmp/binary
  colormap:  # Colorisation et légende pour chaque classe
    - {value: 0, description: "NODATA", color: [0, 0, 0]}
    - {value: 1, description: "Defaut", color: [150, 150, 150]}
    - {value: 2, description: "Sol", color: [207, 150, 70]}
    - {value: 3, description: "Vegetation basse", color: [90, 110, 40]}
    - {value: 4, description: "Vegetation intermediaire", color: [70, 150, 60]}
    - {value: 5, description: "Vegetation haute", color: [70, 150, 60]}
    - {value: 6, description: "Batiment", color: [180, 20, 20]}
    - {value: 9, description: "Eau", color: [40, 140, 140]}
    - {value: 17, description: "Pont", color: [85, 97, 137]}
    - {value: 64, description: "Sursol perenne", color: [255, 0, 255]}
    - {value: 65, description: "Artefact", color: [64, 0, 128]}
    - {value: 66, description: "Point virtuel", color: [128, 0, 64]}
    - {value: 67, description: "DiversBatiment", color: [180, 20, 20]}
    - {value: 50, description: "VegBatiPont", color: [85, 97, 137]}
    - {value: 51, description: "VegBati", color: [70, 150, 60]}
    - {value: 52, description: "VegPont", color: [80, 113, 114]}
    - {value: 53, description: "VegSSP", color: [255, 0, 255]}
    - {value: 60, description: "BatiPont", color: [85, 97, 137]}
    - {value: 61, description: "BatiSSP", color: [255, 0, 255]}
    - {value: 160, description: "VirtSol", color: [207, 150, 70]}
    - {value: 161, description: "VirtVeget", color: [70, 150, 60]}
    - {value: 162, description: "VirtPont", color: [85, 97, 137]}
  dxm_filter:  # Paramètres pour le calcul du MNS (utilisé pour l'ombrage), dimension à filtrer et
               # valeur à garder, par défaut on utilise la dimension créée dans la phase de preprocessing
               # des produits dérivés
    dimension: dsm_marker
    keep_values: [1]
  post_processing:  # Traitements à appliquer à la carte de classe
    fillnodata:  # Filtre gdal.FillNodata. Voir la doc de gdal pour plus de précision sur les différents paramètres
      apply: false  # Booléen: si true, on applique ce traitement
      max_distance: 2  # paramètre maxSearchDist (distance maximale où l'algo va chercher des valeurs à interpoler)
      smoothing_iterations: 0  # paramètre smoothingIterations (Le nombre d'itérations de filtre moyennant avec un noyau 3x3
                               # à appliquer après l'interpolation pour limiter les artefacts)
    smoothing: # Le traitement smoothing utilise le filtre GdalSieveFilter puis fusionne le résultat
               # avec la carte non filtrée pour ne pas agrandir les bâtiments là où il n'y avait pas de données
              # intialement (voir la fonction `choose_pixel_to_keep` pour plus de détails)
      apply: true # Booléen: si true, on applique ce traitement
      nconnectedness: 4 # Paramètre nConnectedness de GdalSieveFilter: (pixels à considérer comme adjacents pour le filtre
                        # 4: les pixels en diagonale ne sont pas considérés adjacents
                        # 8 les pixels en diagonale sont considérés comme adjacents)
      threshold : 12 # Paramètre nSizeThreshold de GdalSieveFilter: les polygones avec une taille en pixels inférieure
                     # à threshold vont être fusionnés avec leur plus grand voisin

  hillshade_calc: "0.95*A*(0.2+0.6*(B/255))"  # Expression pour le calcul de l'ombrage de la carte de classe
                                              # A: raster de classification avant l'ombrage
                                              # B: MNS à utiliser pour l'ombrage

hydra:
  output_subdir: null
  run:
    dir: .
